(defun init-board()
  (let ((board (make-array (* *board-size* *board-size*)
					      :element-type 'fixnum)))
    (set-to-board board 3 4 *white*)
    (set-to-board board 4 4 *black*)
    (set-to-board board 3 3 *black*)
    (set-to-board board 4 3 *white*)
    board))

(defun is-in-board (x y)
  (if (and (not (null x)) (not (null y))
       (>= x 0) (< x *board-size*) (>= y 0) (< y *board-size*))
      t
      nil))

(defun get-next-x (x dir)
  (if (is-right-dir dir) (incf x))
  (if (is-left-dir dir) (decf x))
  x)
(defun get-next-y (y dir)
  (if (is-up-dir dir) (decf y))
  (if (is-down-dir dir) (incf y))
  y)

(defun get-next-cell (x y dir)
  (setf x (get-next-x x dir))
  (setf y (get-next-y y dir))
  (if (is-in-board x y) (cons x y) nil))

; TODO: error processing (by the range of x and y)
(defun set-to-board(board x y piece)
  (let ((pnt (+ (* x *board-size*) y)))
	(setf (aref board pnt) piece))
  board)

(defun get-piece(board x y)
  (if (not (is-in-board x y))
      (return-from get-piece nil))
  (let ((pnt (+ (* x *board-size*) y)))
	(aref board pnt)))
  

(defun print-board(board)
  (dotimes (i 3) (princ '\ ))
  (dotimes (x *board-size*) (princ x))
  (fresh-line)
  (dotimes (y *board-size*)
    (princ `\|) (princ y) (princ '\ )
    (dotimes (x *board-size*)
      (let ((cell (get-piece board x y)))
	(cond ((eq cell 1) (princ 'o))
	      ((eq cell -1) (princ 'x))
	      (t (princ '-)))))
    (princ "\ |")
    (fresh-line)))

(defun count-reverse-to-same(board x y dir turn now-dist)
  (let ((next-cell (get-next-cell x y dir))
	(rev-turn (reverse-turn turn)))
    (if next-cell
	(let* ((next-x (car next-cell))
	       (next-y (cdr next-cell))
	       (next-piece (get-piece board next-x next-y)))
	  (cond ((eq next-piece turn) now-dist)
		((eq next-piece rev-turn)
		 (count-reverse-to-same board next-x next-y dir turn (+ now-dist 1)))
		(t 0)))
	0)))

(defun is-invalid-pnt-turn (x y turn)
  (or (is-empty turn)
      (not (is-in-board x y))))
	   
(defun check-move-valid(board x y turn)
  (if (or (is-invalid-pnt-turn x y turn)
	  (not (is-empty (get-piece board x y))))
      (return-from check-move-valid nil))
  (dotimes (dir 8)
    (if (< 0 (count-reverse-to-same board x y dir turn 0))
	(return-from check-move-valid t)))
  nil)

(defun make-moves-on-board(board turn)
  (let ((moves (list)))
    (dotimes (y *board-size*)
      (dotimes (x *board-size*)
	(if (check-move-valid board x y turn)
	    (setf moves (add-move moves x y)))))
    moves))

(defun move-on-board (board x y turn)
  (if (or (is-invalid-pnt-turn x y turn)
	  (not (check-move-valid board x y turn)))
      (return-from move-on-board nil))
  (let ((reverse-list nil))
    (set-to-board board x y turn)
    (labels ((reverse-piece (next-x next-y dir)
	       (when (is-reverse turn (get-piece board next-x next-y))
		   (set-to-board board next-x next-y turn)
		   (setf reverse-list (cons `(,next-x . ,next-y) reverse-list))
		   (reverse-piece
		    (get-next-x next-x dir)
		    (get-next-y next-y dir)
		    dir))))
      (dotimes (dir 8)
	(if (< 0 (count-reverse-to-same board x y dir turn 0))
	    (reverse-piece (get-next-x x dir) (get-next-y y dir) dir))))
    reverse-list))

(defun count-piece (board turn)
  (if (or (is-empty turn)
	  (not (arrayp board)))
      (return-from count-piece nil))
  (loop for i below (* *board-size* *board-size*)
       count (= (aref board i) turn)))
